# Postgres

## Урок 7.

1. Установить ограничения на таблицу товаров.

Итак наша legacy таблица goods (товары), имеет следующую структуру:

|Колонка         |Тип                                             |
|----------------|------------------------------------------------|
| id             | integer autoincrement [nextval('goods_id_seq')]|
| title          | character varying(255) NULL                    |
| vendor_code    | character(9)                                   |
| image_url      | character varying(255) NULL                    |
| price          | integer                                        |
| old_price      | integer NULL                                   |
| warehouse_date | timestamptz NULL [now()]                       |
| quantity       | smallint NULL                                  |
| category_id    | integer NULL                                   |
| brand_id       | integer NULL                                   |

Проверим, а не установлены ли ранее какие либо ограничения. Стоит отметить, что, первичные и внешние ключи также являются
CONSTRAINT - ограничение. Но для данного задания нас будет интересовать только тип CONSTRAINT - Check.

 Переходим во вкладку "зависимые" и видим что на поля
"price" и "old_price" таблицы уже были установлены ограничения типа Check:

| Тип   | Имя                          | Ограничение|
|-------|------------------------------|------------|
| Check	| public.goods_old_price_check | auto       |
| Check	| public.goods_price_check	   | auto       |
| Check	| public.goods_old_price_check | normal     |
| Check	| public.goods_price_check	   | normal     |

 Для данного задания такой вариант не подойдет, т.к. мы будем как раз устанавливать ограничения типа check на отдельные
 колонки, поэтому перед началом выполнения задания, такого рода ограничения должны быть подчищены:

 ```sql
 ALTER TABLE "goods"
 DROP CONSTRAINT goods_price_check

 ALTER TABLE "goods"
 DROP CONSTRAINT goods_old_price_check
 ```

Все мы избавились от лишенего наследия, можно приступать к выполнению задания:

1 Установим ограничения на цены товаров:

В первую очередь установим ограничения на поле "price". Данное поле может содержать только положительное значение.
Кроме того, можно было бы указать что цена >= 0, но она 0 быть не должна. Сделано это намеренно, так как таблица goods
является витриной магазина и для борьбы с нерадивым товароведом, который выставляя товары и не зная их цены мог бы написать 0.
И кроме того в этом поле у меня не установлено какого бы то ни было значение по умолчанию.
Всё это в совокупности гарантирует, что товары будут выставляться с их действительной ценой или вообще не выставляться.
Итак, запрос:

 ```sql
 ALTER TABLE "goods"
 ADD CONSTRAINT goods_price_check CHECK (price > 0);
 ```

Для старой цены все немного проще, по умолчанию она NULL, поэтому задаём ограничения, что она не должна быть отрицательной
или нулевой.

```sql
 ALTER TABLE "goods"
 ADD CONSTRAINT goods_old_price_check CHECK (old_price > 0);
```

Теперь вставка в любое из этих полей отрицательного или нулевого значения немедленно вызовет ошибку.

Ну и добавим условие о том, что новая цена не должна быть больше старой, так как с точки зрения маркетинга это ошибка.

```sql
 ALTER TABLE "goods"
 ADD CONSTRAINT new_less_old_check CHECK (price <= old_price);
```

Хотелось бы в целях закрепления материала одного из прошлых уроков обратить внимание на то, что этот запрос был выполнен
без ошибок. Дело в том, что в некоторых записях таблицы в поле "old_price" установлено значение NULL. Это значение появилось
там волею PHP скрипта, которым я наполнял таблицу в одной из прошлых домашек. Это поле как и price заполнялось при помощи
функции PHP Rand() и у скрипта была задача проверять, чтобы в это поле не устанавливалась меньшаяя по сравнению с полем
price цена, иначе NULL.
Так вот, Postgress не выдал нам какой-либо ошибки, т.к. значение NULL не подлежит сравнению с чем либо оно всегда <>
всему.

Попробуем поменять значение какой-либо записи таблицы:

```sql
UPDATE "goods"
SET "old_price" = "price" -1
WHERE "id" = 1552
```

Получаем ошибку:
```
ERROR:  new row for relation "goods" violates check constraint "new_less_old_check"
DETAIL:  Failing row contains (1552, Товар51, 00357    , /images/good51, 63716915, 63716914, 2016-08-18 05:39:12+00, 38, 3, 7)
```
И ещё запросы:
```sql
UPDATE "goods"
SET "price" = -1
WHERE "id" = 1670
```

```
ERROR:  new row for relation "goods" violates check constraint "goods_price_check"
DETAIL:  Failing row contains (1670, Товар169, test01183, /images/good169, -1, null, 2016-09-11 09:16:07+00, 25, 6, 2).
```

```sql
UPDATE "goods"
SET "old_price" = 0
WHERE "id" = 1789
```

```
ERROR:  new row for relation "goods" violates check constraint "goods_old_price_check"
DETAIL:  Failing row contains (1789, Товар288, 02016    , /images/good288, 36353306, 0, 2016-07-05 06:40:12+00, 12, 9, 6).
```

2 Ограничение на артикулы.
В принципе на поле vendor_code (артикул) уже стоит одно ограничение типа Unique. Ну и кроме того есть ограничение для по
количеству символов - char(9). Пожалуй мы ещё можем ограничить в добавлении символов, не являющихся числовыми или
текстовыми. Для этого нам потребуется составить регулярное выражение и добавить его в запрос.

3 Ограничение на поле "есть на складе".
Собственно говоря в моей таблице такого поля нет. Но это легко исправить.
```sql
ALTER TABLE "goods"
ADD "presence" boolean DEFAULT 'false';
```
Мы вынуждены были задать значение по умолчанию, чтобы не получить ошибку, т.к. записи в таблице у нас уже есть.
Данное поле напрямую зависит от значения поля quantity, и наверное здесь неплохо было бы написать тригер. Но для начала
хотя бы нужно просто "синхронизировать" это поле с полем quantity:

```sql
UPDATE "goods"
SET "presence" = true
WHERE "quantity" > 0
```

Несмотря на булев тип, на данный момент в поле presence можно записать 3 значения - true, false и NULL.
Исправим это:

```sql
 ALTER TABLE "goods"
 ALTER "presence" SET NOT NULL;
```