# MySql

## Урок 3.

## Создаём таблицу c названием goods, пока без каких либо индексов, как это делали в прошлых домашках:

```sql
CREATE TABLE `goods` (  `id` serial,
                        `title` varchar(255),
                        `vendor_code` char(11) NOT NULL,
                        `image_url` varchar(255),
                        `price` integer unsigned NOT NULL,
                        `old_price` integer unsigned NULL,
                        `warehouse_date` timestamp DEFAULT CURRENT_TIMESTAMP,
                        `quantity` smallint unsigned);
```
Как видим, поле id которому мы задали тип serial является bigint(20) unsigned autoicrement и кроме того, имеет индекс
UNIQUE что совершенно естественно, т.к. не может быть двух записей с одинаковыми айдишниками, иначе это катастрофа.
Навесим на него ещё один индекс - PRIMARY KEY, как это требуется по условиям задачи:
```sql
ALTER TABLE `goods`
ADD PRIMARY KEY `id` (`id`)
```
Всё, теперь поле id имеет 2 индекса.
Сделаем уникальным поле артикул:
```sql
ALTER TABLE `goods`
ADD UNIQUE `vendor_code` (`vendor_code`);
```
Первичные настройки готовы, теперь нам нужно наполнить таблицу записями.
Так как нам понадобится очень много (не менее 100000) записей, буду использовать собственноручно написанный скрипт на PHP
с использованием PDO. Логика скрипта предельно проста и даже примитивна. Артикул должен быть уникальным. Здесь ничего не 
стал придумывать, просто порядковый номер итерации умножается на 7(можно любое
другое число). По условиям задания некоторые поля артикула должны содержать строку test. Тоже ничего особенного - на
каждой 15-й итерации к полю прибавляется префикс 'test'.
Широко используется функция php rand(). Так генерируется старая и новая(основная) цена. Причем на каждой итерации мы
проверяем, чтобы новая цена была не выше или равной старой (иначе нет никакого смысла указывать старую цену) и если
условие не соблюдается, то старая цена у нас null. Из за того, что цены формируются рандомно, в отдельных случаях размер
дисконта может составлять чудовищные величины. Однако это не столь важно на данный момент. Кроме того, денежные величины
указаны в копейках.
Также rand() использует генерацию даты появления товара на складе. Мы предполагаем, что товар имеющийся на складе поступил
не раньше последних 14 недель - 8467200 секунд. Ну и количество также генерируется при помощи rand().

Запускаем скрипт /lesson3/scripts/index.php, выбираем пункт меню 'Вставить данные для MySql'. Ждём, когда скрипт закончит
свою работу. Скрипт настроен на заполнение таблицы 200000 записей, однако скрипту не хватило 180 секунд для заполнения таблицы
всеми 200000 тысячами, заполнилось 134182. Ну и ладно, тоже неплохой результат.

`1.` Выбираем 10 самых новых товаров:
```sql
SELECT * FROM `goods` ORDER BY `warehouse_date` DESC LIMIT 10
```
Запрос занял 0.6553 сек.
Делаем explain и получаем, что в переборке участвуют 133455 строк. Естественно никакие индексы не участвуют.
Собсвтенно дальше делать эксплейны для 'безиндексных' полей делать не будем, так как результат будет ровно таким же. 

Вешаем индекс:
```sql
ALTER TABLE `goods` ADD INDEX idate(`warehouse_date` DESC);
```
Повторяем запрос - Запрос занял 0.1531 сек. Запрос выполнился быстрее почти в 5 раз.
Смотрим EXPLAIN видим, что в поиске участвует всего 10 строк вместо 133455. Круто! В качестве ключа использовался наш индекс
idate.

`2`. Выбираем 10 самых дешевых товаров
```sql
SELECT * FROM `goods` ORDER BY `price` LIMIT 10
```
Запрос занял 0.5159 сек

Вешаем индекс на поле price:
```sql
ALTER TABLE `goods` ADD INDEX price(`price`);
```
Повторяем запрос:
Запрос занял 0.0850 сек. почти в 10 раз
В explain также видим, что в поиске участвовало также 10 строк.

`3`. Выбираем 10 товаров, цена на которых была максимально снижена (в абсолютном или относительном смысле)
```sql
SELECT *,`old_price`-`price` AS `discount` FROM `goods` WHERE `old_price` > `price` ORDER BY `old_price` DESC LIMIT 10
```

Создаём индекс:
```sql
ALTER TABLE `goods`
ADD INDEX `old_price` (`old_price`);
```
Повторяем запрос:
Запрос занял 0.0004 сек. В explain было использовано 10 строк ключ old_price

`4`. Выбираем те товары, чей артикул начинается с символов "test"
```sql
SELECT * FROM `goods` WHERE `vendor_code` LIKE 'test%'
```
Запрос занял 0.0696 сек
```sql
ALTER TABLE `goods` ADD INDEX vendor(`vendor_code`);
```
Запрос занял 0.0221 сек

Смотрим EXPLAIN - в поиске участвовал 19494 записей, при том, что выбрано в итоге было 10321. Key - vendor-code.
